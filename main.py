import logging
import os
import random
import sqlite3
import time
import asyncio
from flask import Flask, request, jsonify
from telegram import Update, Bot, BotCommand, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
from telegram.request import HTTPXRequest
import httpx
from dotenv import load_dotenv

# –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–º—ñ–Ω–Ω–∏—Ö —ñ–∑ .env
load_dotenv()

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# –õ–æ–∫–∞–ª—å–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
try:
    Vadym_ID = int(os.getenv("Vadym_ID", 0))
    Nazar_ID = int(os.getenv("Nazar_ID", 0))
except (ValueError, TypeError) as e:
    logger.error(f"Error reading Vadym_ID or Nazar_ID: {e}")
    Vadym_ID, Nazar_ID = 0, 0
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///bot.db")

if not TELEGRAM_TOKEN:
    logger.error("TELEGRAM_TOKEN is not set")
    raise ValueError("TELEGRAM_TOKEN is required")

# –°–ø–∏—Å–æ–∫ –∞–¥–º—ñ–Ω—ñ–≤
ADMIN_IDS = [id for id in [Vadym_ID, Nazar_ID] if id != 0]
logger.info(f"ADMIN_IDS: {ADMIN_IDS}")

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è HTTPX —ñ–∑ –±—ñ–ª—å—à–∏–º –ø—É–ª–æ–º –∑‚Äô—î–¥–Ω–∞–Ω—å
telegram_request = HTTPXRequest(
    connection_pool_size=100
)

# –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è Flask
app = Flask(__name__)

# –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è Telegram Bot —ñ Application
bot = Bot(token=TELEGRAM_TOKEN, request=telegram_request)
app_telegram = Application.builder().token(TELEGRAM_TOKEN).request(telegram_request).build()

# –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö SQLite
def init_db():
    conn = sqlite3.connect("bot.db")
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        username TEXT,
        character_name TEXT UNIQUE,
        fighter_type TEXT
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS fighter_stats (
        user_id INTEGER PRIMARY KEY,
        fighter_type TEXT,
        stamina REAL,
        strength REAL,
        reaction REAL,
        health REAL,
        punch_speed REAL,
        will REAL,
        FOREIGN KEY (user_id) REFERENCES users (user_id)
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS matches (
        match_id INTEGER PRIMARY KEY AUTOINCREMENT,
        player1_id INTEGER,
        player2_id INTEGER,
        status TEXT,
        start_time REAL,
        current_round INTEGER,
        player1_action TEXT,
        player2_action TEXT,
        player1_health REAL,
        player1_stamina REAL,
        player2_health REAL,
        player2_stamina REAL,
        action_deadline REAL,
        FOREIGN KEY (player1_id) REFERENCES users (user_id),
        FOREIGN KEY (player2_id) REFERENCES users (user_id)
    )""")
    conn.commit()
    conn.close()

init_db()

# –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ maintenance mode
maintenance_mode = False

async def check_maintenance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if maintenance_mode and update.effective_user.id not in ADMIN_IDS:
        await update.message.reply_text("–ë–æ—Ç –Ω–∞ —Ç–µ—Ö–Ω—ñ—á–Ω–∏—Ö —Ä–æ–±–æ—Ç–∞—Ö. –°–ø—Ä–æ–±—É–π –ø—ñ–∑–Ω—ñ—à–µ.")
        return False
    return True

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ –º–µ–Ω—é –¥–ª—è –∞–¥–º—ñ–Ω–∞
async def set_admin_commands(user_id):
    admin_commands = [
        BotCommand("admin_setting", "–ê–¥–º—ñ–Ω-–ø–∞–Ω–µ–ª—å"),
        BotCommand("maintenance_on", "–£–≤—ñ–º–∫–Ω—É—Ç–∏ —Ç–µ—Ö. —Ä–æ–±–æ—Ç–∏"),
        BotCommand("maintenance_off", "–í–∏–º–∫–Ω—É—Ç–∏ —Ç–µ—Ö. —Ä–æ–±–æ—Ç–∏"),
    ]
    try:
        await bot.set_my_commands(commands=admin_commands, scope={"type": "chat", "chat_id": user_id})
        logger.info(f"Set admin commands for user {user_id}")
    except Exception as e:
        logger.error(f"Failed to set commands for {user_id}: {e}")

# –ö–æ–º–∞–Ω–¥–∞ /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.debug(f"Received /start from user {update.effective_user.id}")
    user_id = update.effective_user.id
    if user_id in ADMIN_IDS and not context.user_data.get(f"admin_commands_set_{user_id}"):
        await set_admin_commands(user_id)
        context.user_data[f"admin_commands_set_{user_id}"] = True
    if not await check_maintenance(update, context):
        return
    await update.message.reply_text(
        "–í—ñ—Ç–∞—î–º–æ —É Box Manager Online! –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π /create_account, —â–æ–± —Å—Ç–≤–æ—Ä–∏—Ç–∏ –∞–∫–∞—É–Ω—Ç, –∞–±–æ /start_match, —â–æ–± –ø–æ—á–∞—Ç–∏ –±—ñ–π."
    )

# –ö–æ–º–∞–Ω–¥–∞ /create_account
async def create_account(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.debug(f"Received /create_account from user {update.effective_user.id}")
    if not await check_maintenance(update, context):
        return
    user_id = update.effective_user.id
    conn = sqlite3.connect("bot.db")
    c = conn.cursor()
    c.execute("SELECT user_id FROM users WHERE user_id = ?", (user_id,))
    if c.fetchone():
        await update.message.reply_text("–¢–∏ –≤–∂–µ –º–∞—î—à –∞–∫–∞—É–Ω—Ç! –í–∏–∫–æ—Ä–∏—Å—Ç–∞–π /delete_account, —â–æ–± –≤–∏–¥–∞–ª–∏—Ç–∏ –π–æ–≥–æ.")
        conn.close()
        return
    context.user_data["awaiting_character_name"] = True
    await update.message.reply_text("–í–≤–µ–¥–∏ —ñ–º'—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ (–Ω—ñ–∫ —É –≥—Ä—ñ):")
    conn.close()

# –û–±—Ä–æ–±–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –≤–≤–æ–¥—É –¥–ª—è —ñ–º–µ–Ω—ñ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
async def handle_character_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.debug(f"Received text input from user {update.effective_user.id}: {update.message.text}")
    if not context.user_data.get("awaiting_character_name"):
        return
    if not await check_maintenance(update, context):
        return
    user_id = update.effective_user.id
    character_name = update.message.text.strip()
    conn = sqlite3.connect("bot.db")
    c = conn.cursor()
    c.execute("SELECT character_name FROM users WHERE character_name = ?", (character_name,))
    if c.fetchone():
        await update.message.reply_text("–¶–µ–π –Ω—ñ–∫ —É–∂–µ –∑–∞–π–Ω—è—Ç–∏–π. –í–∏–±–µ—Ä–∏ —ñ–Ω—à–∏–π.")
        conn.close()
        return
    try:
        c.execute(
            "INSERT INTO users (user_id, username, character_name) VALUES (?, ?, ?)",
            (user_id, update.effective_user.username, character_name),
        )
        conn.commit()
        context.user_data["awaiting_character_name"] = False
        context.user_data["awaiting_fighter_type"] = True
        context.user_data["character_name"] = character_name
        fighter_descriptions = (
            "–í–∏–±–µ—Ä–∏ —Ç–∏–ø –±—ñ–π—Ü—è (–∑–º—ñ–Ω–∏—Ç–∏ –≤–∏–±—ñ—Ä –ø–æ—Ç—ñ–º –Ω–µ–º–æ–∂–ª–∏–≤–æ):\n\n"
            "üî• *Swarmer*: –ê–≥—Ä–µ—Å–∏–≤–Ω–∏–π –±–æ—î—Ü—å. –í–∏—Å–æ–∫–∞ —Å–∏–ª–∞ (1.5), –≤–æ–ª—è (1.5), —à–≤–∏–¥–∫—ñ—Å—Ç—å —É–¥–∞—Ä—É (1.35). –ó–¥–æ—Ä–æ–≤‚Äô—è: 120, –≤–∏–Ω–æ—Å–ª–∏–≤—ñ—Å—Ç—å: 1.1.\n"
            "ü•ä *Out-boxer*: –í–∏—Ç—Ä–∏–≤–∞–ª–∏–π —ñ —Ç–∞–∫—Ç–∏—á–Ω–∏–π. –í–∏—Å–æ–∫–∞ –≤–∏–Ω–æ—Å–ª–∏–≤—ñ—Å—Ç—å (1.5), –∑–¥–æ—Ä–æ–≤‚Äô—è (200). –°–∏–ª–∞: 1.15, –≤–æ–ª—è: 1.3.\n"
            "‚ö° *Counter-puncher*: –ú–∞–π—Å—Ç–µ—Ä –∫–æ–Ω—Ç—Ä–∞—Ç–∞–∫–∏. –í–∏—Å–æ–∫–∞ —Ä–µ–∞–∫—Ü—ñ—è (1.5), —à–≤–∏–¥–∫—ñ—Å—Ç—å —É–¥–∞—Ä—É (1.5). –°–∏–ª–∞: 1.25, –∑–¥–æ—Ä–æ–≤‚Äô—è: 100, –≤–æ–ª—è: 1.2."
        )
        keyboard = [
            [InlineKeyboardButton("Swarmer", callback_data="swarmer")],
            [InlineKeyboardButton("Out-boxer", callback_data="out_boxer")],
            [InlineKeyboardButton("Counter-puncher", callback_data="counter_puncher")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(fighter_descriptions, reply_markup=reply_markup, parse_mode="Markdown")
    except sqlite3.IntegrityError:
        await update.message.reply_text("–¶–µ–π –Ω—ñ–∫ —É–∂–µ –∑–∞–π–Ω—è—Ç–∏–π. –í–∏–±–µ—Ä–∏ —ñ–Ω—à–∏–π.")
    finally:
        conn.close()

# –û–±—Ä–æ–±–∫–∞ –≤–∏–±–æ—Ä—É —Ç–∏–ø—É –±—ñ–π—Ü—è
async def handle_fighter_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    logger.debug(f"Received fighter type selection from user {query.from_user.id}: {query.data}")
    if not context.user_data.get("awaiting_fighter_type"):
        await query.message.reply_text("–ü–æ–º–∏–ª–∫–∞: –≤–∏–±—ñ—Ä –±—ñ–π—Ü—è –≤–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ.")
        return
    user_id = query.from_user.id
    fighter_type = query.data
    character_name = context.user_data.get("character_name")
    
    # –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –±—ñ–π—Ü—ñ–≤
    fighter_stats = {
        "swarmer": {
            "stamina": 1.1,
            "total_stamina": 100,
            "strength": 1.5,
            "reaction": 1.1,
            "health": 120,
            "punch_speed": 1.35,
            "will": 1.5
        },
        "out_boxer": {
            "stamina": 1.5,
            "total_stamina": 100,
            "strength": 1.15,
            "reaction": 1.1,
            "health": 200,
            "punch_speed": 1.1,
            "will": 1.3
        },
        "counter_puncher": {
            "stamina": 1.15,
            "total_stamina": 100,
            "strength": 1.25,
            "reaction": 1.5,
            "health": 100,
            "punch_speed": 1.5,
            "will": 1.2
        }
    }
    
    conn = sqlite3.connect("bot.db")
    c = conn.cursor()
    try:
        # –û–Ω–æ–≤–ª—é—î–º–æ —Ç–∏–ø –±—ñ–π—Ü—è –≤ —Ç–∞–±–ª–∏—Ü—ñ users
        c.execute(
            "UPDATE users SET fighter_type = ? WHERE user_id = ?",
            (fighter_type, user_id)
        )
        # –î–æ–¥–∞—î–º–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü—é fighter_stats
        stats = fighter_stats[fighter_type]
        c.execute(
            """INSERT INTO fighter_stats (user_id, fighter_type, stamina, strength, reaction, health, punch_speed, will)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
            (user_id, fighter_type, stats["stamina"], stats["strength"], stats["reaction"],
             stats["health"], stats["punch_speed"], stats["will"])
        )
        conn.commit()
        await query.message.reply_text(f"–ê–∫–∞—É–Ω—Ç —Å—Ç–≤–æ—Ä–µ–Ω–æ! –ü–µ—Ä—Å–æ–Ω–∞–∂: {character_name}, –¢–∏–ø: {fighter_type.capitalize()}")
    except sqlite3.IntegrityError:
        await query.message.reply_text("–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—ñ –±—ñ–π—Ü—è. –°–ø—Ä–æ–±—É–π —â–µ —Ä–∞–∑.")
    finally:
        conn.close()
        context.user_data["awaiting_fighter_type"] = False
        context.user_data["character_name"] = None

# –ö–æ–º–∞–Ω–¥–∞ /delete_account
async def delete_account(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.debug(f"Received /delete_account from user {update.effective_user.id}")
    if not await check_maintenance(update, context):
        return
    user_id = update.effective_user.id
    conn = sqlite3.connect("bot.db")
    c = conn.cursor()
    c.execute("SELECT user_id FROM users WHERE user_id = ?", (user_id,))
    if not c.fetchone():
        await update.message.reply_text("–£ —Ç–µ–±–µ –Ω–µ–º–∞—î –∞–∫–∞—É–Ω—Ç–∞!")
        conn.close()
        return
    c.execute("DELETE FROM users WHERE user_id = ?", (user_id,))
    c.execute("DELETE FROM fighter_stats WHERE user_id = ?", (user_id,))
    c.execute("DELETE FROM matches WHERE player1_id = ? OR player2_id = ?", (user_id, user_id))
    conn.commit()
    conn.close()
    await update.message.reply_text("–ê–∫–∞—É–Ω—Ç –≤–∏–¥–∞–ª–µ–Ω–æ! –ú–æ–∂–µ—à —Å—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é /create_account.")

# –ö–æ–º–∞–Ω–¥–∞ /start_match
async def start_match(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.debug(f"Received /start_match from user {update.effective_user.id}")
    if not await check_maintenance(update, context):
        return
    user_id = update.effective_user.id
    conn = sqlite3.connect("bot.db")
    c = conn.cursor()
    c.execute("SELECT user_id, character_name, fighter_type FROM users WHERE user_id = ?", (user_id,))
    user = c.fetchone()
    if not user:
        await update.message.reply_text("–°–ø–æ—á–∞—Ç–∫—É —Å—Ç–≤–æ—Ä–∏ –∞–∫–∞—É–Ω—Ç –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é /create_account!")
        conn.close()
        return
    
    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –≥—Ä–∞–≤–µ—Ü—å —É–∂–µ –≤ –º–∞—Ç—á—ñ
    c.execute("SELECT match_id FROM matches WHERE (player1_id = ? OR player2_id = ?) AND status = 'active'", (user_id, user_id))
    if c.fetchone():
        await update.message.reply_text("–¢–∏ –≤–∂–µ –≤ –º–∞—Ç—á—ñ! –ó–∞–∫—ñ–Ω—á–∏ –ø–æ—Ç–æ—á–Ω–∏–π –±—ñ–π.")
        conn.close()
        return
    
    # –®—É–∫–∞—î–º–æ —ñ–Ω—à–æ–≥–æ –≥—Ä–∞–≤—Ü—è
    c.execute("SELECT user_id, character_name, fighter_type FROM users WHERE user_id != ? AND user_id NOT IN (SELECT player1_id FROM matches WHERE status = 'active') AND user_id NOT IN (SELECT player2_id FROM matches WHERE status = 'active')", (user_id,))
    opponents = c.fetchall()
    if not opponents:
        await update.message.reply_text("–ù–µ–º–∞—î –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —Å—É–ø–µ—Ä–Ω–∏–∫—ñ–≤. –°–ø—Ä–æ–±—É–π –ø—ñ–∑–Ω—ñ—à–µ.")
        conn.close()
        return
    
    opponent = random.choice(opponents)
    opponent_id, opponent_name, opponent_type = opponent
    
    # –û—Ç—Ä–∏–º—É—î–º–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –≥—Ä–∞–≤—Ü—ñ–≤
    c.execute("SELECT health, total_stamina FROM fighter_stats WHERE user_id = ?", (user_id,))
    player_stats = c.fetchone()
    c.execute("SELECT health, total_stamina FROM fighter_stats WHERE user_id = ?", (opponent_id,))
    opponent_stats = c.fetchone()
    
    # –°—Ç–≤–æ—Ä—é—î–º–æ –º–∞—Ç—á —ñ–∑ –¥–µ–¥–ª–∞–π–Ω–æ–º –¥–ª—è –¥—ñ—ó
    action_deadline = time.time() + 15  # 15 —Å–µ–∫—É–Ω–¥ –Ω–∞ –¥—ñ—é
    c.execute(
        """INSERT INTO matches (player1_id, player2_id, status, start_time, current_round, player1_health, player1_stamina, player2_health, player2_stamina, action_deadline)
        VALUES (?, ?, 'active', ?, 1, ?, ?, ?, ?, ?)""",
        (user_id, opponent_id, time.time(), player_stats[0], player_stats[1], opponent_stats[0], opponent_stats[1], action_deadline)
    )
    conn.commit()
    match_id = c.lastrowid
    conn.close()
    
    # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –æ–±–æ–º –≥—Ä–∞–≤—Ü—è–º
    await update.message.reply_text(
        f"–ú–∞—Ç—á —Ä–æ–∑–ø–æ—á–∞—Ç–æ! –¢–∏ ({user[1]}, {user[2].capitalize()}) –ø—Ä–æ—Ç–∏ {opponent_name} ({opponent_type.capitalize()}). –ë—ñ–π —Ç—Ä–∏–≤–∞—î 3 —Ö–≤–∏–ª–∏–Ω–∏. –û–±–µ—Ä–∏ –¥—ñ—é (15 —Å–µ–∫—É–Ω–¥):",
        reply_markup=get_fight_keyboard(match_id)
    )
    await bot.send_message(
        chat_id=opponent_id,
        text=f"–ú–∞—Ç—á —Ä–æ–∑–ø–æ—á–∞—Ç–æ! –¢–∏ ({opponent_name}, {opponent_type.capitalize()}) –ø—Ä–æ—Ç–∏ {user[1]} ({user[2].capitalize()}). –ë—ñ–π —Ç—Ä–∏–≤–∞—î 3 —Ö–≤–∏–ª–∏–Ω–∏. –û–±–µ—Ä–∏ –¥—ñ—é (15 —Å–µ–∫—É–Ω–¥):",
        reply_markup=get_fight_keyboard(match_id)
    )

# –ö–ª–∞–≤—ñ–∞—Ç—É—Ä–∞ –¥–ª—è –±–æ—é
def get_fight_keyboard(match_id):
    keyboard = [
        [InlineKeyboardButton("–í–¥–∞—Ä–∏—Ç–∏", callback_data=f"fight_{match_id}_attack")],
        [InlineKeyboardButton("–£—Ö–∏–ª–∏—Ç–∏—Å—è", callback_data=f"fight_{match_id}_dodge")],
        [InlineKeyboardButton("–ë–ª–æ–∫", callback_data=f"fight_{match_id}_block")],
        [InlineKeyboardButton("–í—ñ–¥–ø–æ—á–∏–Ω–æ–∫", callback_data=f"fight_{match_id}_rest")]
    ]
    return InlineKeyboardMarkup(keyboard)

# –û–±—Ä–æ–±–∫–∞ –¥—ñ–π —É –±–æ—é
async def handle_fight_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    logger.debug(f"Received fight action from user {query.from_user.id}: {query.data}")
    user_id = query.from_user.id
    callback_data = query.data.split("_")
    match_id, action = int(callback_data[1]), callback_data[2]
    
    conn = sqlite3.connect("bot.db")
    c = conn.cursor()
    c.execute("SELECT player1_id, player2_id, player1_action, player2_action, status, action_deadline FROM matches WHERE match_id = ?", (match_id,))
    match = c.fetchone()
    if not match or match[4] != "active":
        await query.message.reply_text("–ú–∞—Ç—á –∑–∞–≤–µ—Ä—à–µ–Ω–æ –∞–±–æ –Ω–µ —ñ—Å–Ω—É—î.")
        conn.close()
        return
    
    player1_id, player2_id, player1_action, player2_action, status, action_deadline = match
    
    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –¥–µ–¥–ª–∞–π–Ω
    if time.time() > action_deadline:
        await query.message.reply_text("–ß–∞—Å –¥–ª—è –¥—ñ—ó –º–∏–Ω—É–≤! –†–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à–µ–Ω–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ.")
        await process_round(match_id, context, timed_out=True)
        conn.close()
        return
    
    # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –¥—ñ—é –≥—Ä–∞–≤—Ü—è
    if user_id == player1_id:
        c.execute("UPDATE matches SET player1_action = ? WHERE match_id = ?", (action, match_id))
    elif user_id == player2_id:
        c.execute("UPDATE matches SET player2_action = ? WHERE match_id = ?", (action, match_id))
    else:
        await query.message.reply_text("–¢–∏ –Ω–µ —É—á–∞—Å–Ω–∏–∫ —Ü—å–æ–≥–æ –º–∞—Ç—á—É!")
        conn.close()
        return
    
    conn.commit()
    
    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –æ–±–∏–¥–≤–∞ –≥—Ä–∞–≤—Ü—ñ –≤–∏–±—Ä–∞–ª–∏ –¥—ñ—ó
    c.execute("SELECT player1_action, player2_action FROM matches WHERE match_id = ?", (match_id,))
    actions = c.fetchone()
    if actions[0] and actions[1]:
        # –û–±–∏–¥–≤–∞ –≤–∏–±—Ä–∞–ª–∏, –æ–±—Ä–æ–±–ª—è—î–º–æ —Ä–∞—É–Ω–¥
        await process_round(match_id, context)
    
    conn.close()

# –û–±—Ä–æ–±–∫–∞ —Ä–∞—É–Ω–¥—É –∑ —Ñ–æ—Ä–º—É–ª–∞–º–∏
async def process_round(match_id, context, timed_out=False):
    conn = sqlite3.connect("bot.db")
    c = conn.cursor()
    c.execute(
        """SELECT player1_id, player2_id, player1_action, player2_action, player1_health, player1_stamina,
        player2_health, player2_stamina, current_round, start_time FROM matches WHERE match_id = ?""",
        (match_id,)
    )
    match = c.fetchone()
    player1_id, player2_id, p1_action, p2_action, p1_health, p1_stamina, p2_health, p2_stamina, round_num, start_time = match
    
    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å –±–æ—é (3 —Ö–≤–∏–ª–∏–Ω–∏ = 180 —Å–µ–∫—É–Ω–¥)
    if time.time() > start_time + 180:
        await end_match(match_id, context, player1_id, player2_id, p1_health, p2_health)
        conn.close()
        return
    
    # –û—Ç—Ä–∏–º—É—î–º–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –≥—Ä–∞–≤—Ü—ñ–≤
    c.execute("SELECT strength, reaction, punch_speed, stamina FROM fighter_stats WHERE user_id = ?", (player1_id,))
    p1_stats = c.fetchone()
    p1_strength, p1_reaction, p1_punch_speed, p1_stamina_stat = p1_stats
    c.execute("SELECT strength, reaction, punch_speed, stamina FROM fighter_stats WHERE user_id = ?", (player2_id,))
    p2_stats = c.fetchone()
    p2_strength, p2_reaction, p2_punch_speed, p2_stamina_stat = p2_stats
    
    result_text = f"–†–∞—É–Ω–¥ {round_num}\¬†Wn"
    
    # –Ø–∫—â–æ —Ç–∞–π–º-–∞—É—Ç, –¥—ñ—ó = "rest"
    if timed_out:
        p1_action = "rest"
        p2_action = "rest"
        result_text += "–ß–∞—Å –º–∏–Ω—É–≤! –û–±–∏–¥–≤–∞ –≥—Ä–∞–≤—Ü—ñ –≤—ñ–¥–ø–æ—á–∏–≤–∞—é—Ç—å.\n"
    
    # –§–æ—Ä–º—É–ª–∏
    base_damage = 10  # –ë–∞–∑–æ–≤–∏–π —É—Ä–æ–Ω —É–¥–∞—Ä—É
    if p1_action == "attack" and p2_action != "dodge" and p2_action != "block":
        damage = base_damage * p1_strength  # –£—Ä–æ–Ω = —É—Ä–æ–Ω –ø—Ä–∏–π–æ–º—É * –°–∏–ª–∞
        p2_health -= damage
        p1_stamina -= 10 * p1_stamina_stat
        result_text += f"–ì—Ä–∞–≤–µ—Ü—å 1 –≤–¥–∞—Ä–∏–≤ –ì—Ä–∞–≤—Ü—è 2! –£—Ä–æ–Ω: {damage:.1f}\n"
    elif p1_action == "attack" and p2_action == "block":
        block_strength = 0.5 * p2_stamina_stat * p2_strength  # –ë–ª–æ–∫ = 0.5 * –í–∏–Ω–æ—Å–ª–∏–≤—ñ—Å—Ç—å * –°–∏–ª–∞
        damage = max(0, base_damage * p1_strength - block_strength)
        p2_health -= damage
        p1_stamina -= 10 * p1_stamina_stat
        result_text += f"–ì—Ä–∞–≤–µ—Ü—å 1 –≤–¥–∞—Ä–∏–≤, –∞–ª–µ –ì—Ä–∞–≤–µ—Ü—å 2 –±–ª–æ–∫—É–≤–∞–≤! –£—Ä–æ–Ω: {damage:.1f}\n"
    elif p1_action == "attack" and p2_action == "dodge":
        dodge_chance = 0.4 * p2_reaction * p2_punch_speed  # –£—Ö–∏–ª–µ–Ω–Ω—è = 0.4 * –†–µ–∞–∫—Ü—ñ—è * –®–≤–∏–¥–∫—ñ—Å—Ç—å —É–¥–∞—Ä—É
        if random.random() < dodge_chance:
            result_text += "–ì—Ä–∞–≤–µ—Ü—å 1 –≤–¥–∞—Ä–∏–≤, –∞–ª–µ –ì—Ä–∞–≤–µ—Ü—å 2 —É—Ö–∏–ª–∏–≤—Å—è!\n"
        else:
            damage = base_damage * p1_strength
            p2_health -= damage
            p1_stamina -= 10 * p1_stamina_stat
            result_text += f"–ì—Ä–∞–≤–µ—Ü—å 1 –≤–¥–∞—Ä–∏–≤ –ì—Ä–∞–≤—Ü—è 2! –£—Ö–∏–ª–µ–Ω–Ω—è –Ω–µ –≤–¥–∞–ª–æ—Å—è. –£—Ä–æ–Ω: {damage:.1f}\n"
    elif p1_action == "rest":
        p1_stamina = min(p1_stamina + 15 * p1_stamina_stat, 100)
        result_text += "–ì—Ä–∞–≤–µ—Ü—å 1 –≤—ñ–¥–ø–æ—á–∏–≤–∞—î.\n"
    
    if p2_action == "attack" and p1_action != "dodge" and p1_action != "block":
        damage = base_damage * p2_strength
        p1_health -= damage
        p2_stamina -= 10 * p2_stamina_stat
        result_text += f"–ì—Ä–∞–≤–µ—Ü—å 2 –≤–¥–∞—Ä–∏–≤ –ì—Ä–∞–≤—Ü—è 1! –£—Ä–æ–Ω: {damage:.1f}\n"
    elif p2_action == "attack" and p1_action == "block":
        block_strength = 0.5 * p1_stamina_stat * p1_strength
        damage = max(0, base_damage * p2_strength - block_strength)
        p1_health -= damage
        p2_stamina -= 10 * p2_stamina_stat
        result_text += f"–ì—Ä–∞–≤–µ—Ü—å 2 –≤–¥–∞—Ä–∏–≤, –∞–ª–µ –ì—Ä–∞–≤–µ—Ü—å 1 –±–ª–æ–∫—É–≤–∞–≤! –£—Ä–æ–Ω: {damage:.1f}\n"
    elif p2_action == "attack" and p1_action == "dodge":
        dodge_chance = 0.4 * p1_reaction * p1_punch_speed
        if random.random() < dodge_chance:
            result_text += "–ì—Ä–∞–≤–µ—Ü—å 2 –≤–¥–∞—Ä–∏–≤, –∞–ª–µ –ì—Ä–∞–≤–µ—Ü—å 1 —É—Ö–∏–ª–∏–≤—Å—è!\n"
        else:
            damage = base_damage * p2_strength
            p1_health -= damage
            p2_stamina -= 10 * p2_stamina_stat
            result_text += f"–ì—Ä–∞–≤–µ—Ü—å 2 –≤–¥–∞—Ä–∏–≤ –ì—Ä–∞–≤—Ü—è 1! –£—Ö–∏–ª–µ–Ω–Ω—è –Ω–µ –≤–¥–∞–ª–æ—Å—è. –£—Ä–æ–Ω: {damage:.1f}\n"
    elif p2_action == "rest":
        p2_stamina = min(p2_stamina + 15 * p2_stamina_stat, 100)
        result_text += "–ì—Ä–∞–≤–µ—Ü—å 2 –≤—ñ–¥–ø–æ—á–∏–≤–∞—î.\n"
    
    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∑–¥–æ—Ä–æ–≤‚Äô—è
    if p1_health <= 0 or p2_health <= 0:
        await end_match(match_id, context, player1_id, player2_id, p1_health, p2_health)
        conn.close()
        return
    
    # –û–Ω–æ–≤–ª—é—î–º–æ –º–∞—Ç—á
    new_deadline = time.time() + 15  # –ù–æ–≤–∏–π –¥–µ–¥–ª–∞–π–Ω
    c.execute(
        """UPDATE matches SET player1_health = ?, player1_stamina = ?, player2_health = ?, player2_stamina = ?,
        player1_action = NULL, player2_action = NULL, current_round = ?, action_deadline = ? WHERE match_id = ?""",
        (p1_health, p1_stamina, p2_health, p2_stamina, round_num + 1, new_deadline, match_id)
    )
    conn.commit()
    
    # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
    status_text = (
        f"–°—Ç–∞–Ω:\n–ì—Ä–∞–≤–µ—Ü—å 1: HP {p1_health:.1f}, –í–∏–Ω–æ—Å–ª–∏–≤—ñ—Å—Ç—å {p1_stamina:.1f}\n"
        f"–ì—Ä–∞–≤–µ—Ü—å 2: HP {p2_health:.1f}, –í–∏–Ω–æ—Å–ª–∏–≤—ñ—Å—Ç—å {p2_stamina:.1f}\n"
        "–û–±–µ—Ä–∏ –Ω–∞—Å—Ç—É–ø–Ω—É –¥—ñ—é (15 —Å–µ–∫—É–Ω–¥):"
    )
    await bot.send_message(
        chat_id=player1_id,
        text=result_text + status_text,
        reply_markup=get_fight_keyboard(match_id)
    )
    await bot.send_message(
        chat_id=player2_id,
        text=result_text + status_text,
        reply_markup=get_fight_keyboard(match_id)
    )
    
    conn.close()

# –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—è –º–∞—Ç—á—É
async def end_match(match_id, context, player1_id, player2_id, p1_health, p2_health):
    conn = sqlite3.connect("bot.db")
    c = conn.cursor()
    c.execute("UPDATE matches SET status = 'finished' WHERE match_id = ?", (match_id,))
    conn.commit()
    conn.close()
    
    if p1_health <= 0 and p2_health <= 0:
        result = "–ù—ñ—á–∏—è! –û–±–∏–¥–≤–∞ –±—ñ–π—Ü—ñ –≤—Ç—Ä–∞—Ç–∏–ª–∏ –≤—Å–µ –∑–¥–æ—Ä–æ–≤‚Äô—è."
    elif p1_health <= 0:
        result = "–ì—Ä–∞–≤–µ—Ü—å 2 –ø–µ—Ä–µ–º—ñ–≥!"
    elif p2_health <= 0:
        result = "–ì—Ä–∞–≤–µ—Ü—å 1 –ø–µ—Ä–µ–º—ñ–≥!"
    else:
        result = "–ú–∞—Ç—á –∑–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ —á–∞—Å–æ–º. –ü–µ—Ä–µ–º–æ–∂–µ—Ü—å –≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è –∑–∞ –∑–¥–æ—Ä–æ–≤‚Äô—è–º:\n"
        result += f"–ì—Ä–∞–≤–µ—Ü—å 1: HP {p1_health:.1f}\n–ì—Ä–∞–≤–µ—Ü—å 2: HP {p2_health:.1f}\n"
        result += "–ì—Ä–∞–≤–µ—Ü—å 1 –ø–µ—Ä–µ–º—ñ–≥!" if p1_health > p2_health else "–ì—Ä–∞–≤–µ—Ü—å 2 –ø–µ—Ä–µ–º—ñ–≥!" if p2_health > p1_health else "–ù—ñ—á–∏—è!"
    
    await bot.send_message(chat_id=player1_id, text=result)
    await bot.send_message(chat_id=player2_id, text=result)

# –ê–¥–º—ñ–Ω—Å—å–∫–∞ –∫–æ–º–∞–Ω–¥–∞ /admin_setting
async def admin_setting(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    logger.debug(f"Received /admin_setting from user {user_id}. ADMIN_IDS: {ADMIN_IDS}")
    if user_id not in ADMIN_IDS:
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ!")
        return
    await update.message.reply_text(
        "–ê–¥–º—ñ–Ω-–ø–∞–Ω–µ–ª—å:\n"
        "/maintenance_on - –£–≤—ñ–º–∫–Ω—É—Ç–∏ —Ç–µ—Ö–Ω—ñ—á–Ω—ñ —Ä–æ–±–æ—Ç–∏\n"
        "/maintenance_off - –í–∏–º–∫–Ω—É—Ç–∏ —Ç–µ—Ö–Ω—ñ—á–Ω—ñ —Ä–æ–±–æ—Ç–∏"
    )

# –£–≤—ñ–º–∫–Ω–µ–Ω–Ω—è —Ç–µ—Ö–Ω—ñ—á–Ω–∏—Ö —Ä–æ–±—ñ—Ç
async def maintenance_on(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    logger.debug(f"Received /maintenance_on from user {user_id}")
    if user_id not in ADMIN_IDS:
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ!")
        return
    global maintenance_mode
    maintenance_mode = True
    await update.message.reply_text("–¢–µ—Ö–Ω—ñ—á–Ω—ñ —Ä–æ–±–æ—Ç–∏ —É–≤—ñ–º–∫–Ω–µ–Ω–æ. –ë–æ—Ç –ø—Ä–∏–∑—É–ø–∏–Ω–µ–Ω–æ.")

# –í–∏–º–∫–Ω–µ–Ω–Ω—è —Ç–µ—Ö–Ω—ñ—á–Ω–∏—Ö —Ä–æ–±—ñ—Ç
async def maintenance_off(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    logger.debug(f"Received /maintenance_off from user {user_id}")
    if user_id not in ADMIN_IDS:
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ!")
        return
    global maintenance_mode
    maintenance_mode = False
    await update.message.reply_text("–¢–µ—Ö–Ω—ñ—á–Ω—ñ —Ä–æ–±–æ—Ç–∏ –≤–∏–º–∫–Ω–µ–Ω–æ. –ë–æ—Ç –∞–∫—Ç–∏–≤–Ω–∏–π.")

# –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫–∏ –∫–æ–º–∞–Ω–¥
app_telegram.add_handler(CommandHandler("start", start))
app_telegram.add_handler(CommandHandler("create_account", create_account))
app_telegram.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_character_name))
app_telegram.add_handler(CallbackQueryHandler(handle_fighter_type, pattern="^(swarmer|out_boxer|counter_puncher)$"))
app_telegram.add_handler(CallbackQueryHandler(handle_fight_action, pattern="^fight_"))
app_telegram.add_handler(CommandHandler("start_match", start_match))
app_telegram.add_handler(CommandHandler("delete_account", delete_account))
app_telegram.add_handler(CommandHandler("admin_setting", admin_setting))
app_telegram.add_handler(CommandHandler("maintenance_on", maintenance_on))
app_telegram.add_handler(CommandHandler("maintenance_off", maintenance_off))

# –í–µ–±—Ö—É–∫ –¥–ª—è Flask (–¥–ª—è –¥–µ–±–∞–≥—É –∞–±–æ –º–∞–π–±—É—Ç–Ω—å–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è)
@app.route("/webhook", methods=["POST"])
def webhook():
    try:
        data = request.get_json()
        logger.debug(f"Webhook received data: {data}")
        update = Update.de_json(data, bot)
        if update:
            app_telegram.process_update(update)
            logger.debug("Webhook processed update successfully")
        else:
            logger.warning("Webhook received no valid update")
        return jsonify({"ok": True})
    except Exception as e:
        logger.error(f"Webhook error: {e}")
        return jsonify({"ok": False}), 500

# Health check –¥–ª—è UptimeRobot
@app.route("/health", methods=["GET"])
def health():
    return jsonify({"status": "ok"})

# –°–∏–Ω—Ö—Ä–æ–Ω–Ω–µ –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –≤–µ–±—Ö—É–∫–∞
def disable_webhook_sync():
    try:
        response = httpx.get(f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/deleteWebhook")
        result = response.json()
        if result.get("ok"):
            logger.info("Webhook disabled successfully")
        else:
            logger.error(f"Failed to disable webhook: {result}")
    except Exception as e:
        logger.error(f"Failed to disable webhook: {e}")

# –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Ç–∞ –∑–∞–ø—É—Å–∫ polling
if __name__ == "__main__":
    logger.info("Starting bot...")
    disable_webhook_sync()  # –í—ñ–¥–∫–ª—é—á–∞—î–º–æ –≤–µ–±—Ö—É–∫
    try:
        logger.info("Initializing bot and starting polling...")
        app_telegram.run_polling(poll_interval=0.5, timeout=10, drop_pending_updates=True)
        logger.info("Polling started successfully")
    except Exception as e:
        logger.error(f"Polling failed: {e}")
        raise